--- buildroot/support/scripts/genimage2.org	2023-03-29 13:42:37.341185816 +0200
+++ buildroot/support/scripts/genimage2.sh	2023-03-29 14:39:42.704375759 +0200
@@ -0,0 +1,143 @@
+#!/bin/bash
+
+substitute () {
+	local value="$1"
+	if [[ "${value:0:1}" == "$" ]]; then
+		local index=1
+		for (( ; index<${#value}; index++ )); do
+			if [[ "${value:$index:1}" == [^a-zA-Z0-9_] ]]; then
+				break
+			fi
+		done
+		replacement="."
+		if [[ $index > 1 ]]; then 
+			variable=${value:1:$((index-1))}
+			replacement=${!variable}
+		fi
+		if [[ "${replacement}" == "" ]]; then
+			replacement="."
+		fi
+		value="$replacement${value:$index}"
+	fi
+	echo $value
+}
+
+# set -x
+
+if [ "$#" -ne 3 ]; then
+	echo "Incorrect argument count; expecting three args - [file with files to be placed in image] [name rootfs] [path to rootfs from which to copy]"
+	exit
+fi
+
+inputFile=$1
+destination=$(dirname $2)
+rootfs=$3
+
+if [[ "$rootfs"  == "" ]] || [[ ! -d "$rootfs" ]]; then
+	echo "The rootfs is not a directory path. Please provide a directory path to the rootfs from which to copy!!"
+	exit
+fi
+
+if [[ "$destination"  == ""  ]]; then
+	destination="./"
+fi
+
+pathNames=()
+list=()
+foreigners=()
+links=()
+
+# Set space as the delimiter
+
+### prepare the input list to easy to understand entries...
+while IFS= read -r line; do
+
+	# read and split words into an array based on space delimiter
+	IFS=' ' read -a words <<< "$line"
+
+	if [[ ${#words[@]} > 1 ]]; then 
+		entry=${words[1]}
+	else
+		entry=${words[0]}
+	fi
+
+	if [[ "${entry: -1}"  == "/"  ]]; then
+		entry="$entry*"
+	fi
+	if [[ "${entry:0:1}"  == "/"  ]]; then
+		entry="${entry:1}"
+	fi
+	if [[ "${entry}" != "" ]]; then
+		pathName=($(dirname -- "$entry"))
+		pathNames+=($pathName)
+
+		if [[ ${#words[@]} > 1 ]]; then 
+			source="${words[0]}"
+
+			if [[ "${source:0:1}" == "@" ]]; then
+				echo "found a link [$source]"
+				if [[ $pathName == "" ]]; then
+					echo "Error can not create symbolic link for ${source}, empty destination!"
+				else
+					links+=("${source:1} $entry")
+				fi
+			else
+				echo "found a foreigner [$source]"
+				if [[ $pathName == "" ]]; then
+					pathName="."
+				fi
+				foreigners+=("${words[0]} $pathName")
+			fi
+		else
+			list+=( "$entry" )
+		fi
+	fi
+done < $inputFile
+
+pathNames=($(echo "${pathNames[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
+
+temporary=$(mktemp -d "$destination/image.XXXXXX")
+echo "Creating temporary space here: $temporary"
+mkdir -p $temporary
+
+pushd $temporary
+
+touch initramfs
+
+### create all the directories required in the temp image
+for directory in "${pathNames[@]}"; do
+	if [[ "$directory" != "/"  ]]; then
+		echo "Creating $temporary/$directory"
+		mkdir -p "$directory"
+	fi
+done
+
+### insert all the files that are allocated outside of the IMAGE
+for entry in "${foreigners[@]}"; do
+	IFS=" " read -a words <<< "$entry"
+	sourceFile=$(substitute "${words[0]}")
+	cp -prvf $sourceFile "${words[1]}"
+done
+
+### copy all files requested in the input file to the output image
+for entry in "${list[@]}"; do
+	pathName=$(dirname -- "$entry")
+	if [[ "$pathName" == ""  ]]; then
+		pathName="."
+	fi
+	cp -prvf $rootfs/$entry "$pathName"
+done
+
+for entry in "${links[@]}"; do
+	IFS=" " read -a words <<< "$entry"
+	ln -sfv "${words[0]}" "${words[1]}"
+done
+
+### create cpio archive
+find | fakeroot cpio -H newc -o | xz -C crc32 --verbose > ./__initramfs.cpio.xz && dd if=./__initramfs.cpio.xz of=./__initramfs.cpio.padded bs=4k conv=sync
+
+popd
+
+mv $temporary/__initramfs.cpio.padded $2 
+rm -rf $temporary
+
